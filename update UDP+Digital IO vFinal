#include <SPI.h>
#include <Ethernet.h>
#include <TimerOne.h>

struct Gimbal {
  unsigned int LS_ARM_EXT : 1;        //bit 0
  unsigned int LS_INTL_EXT : 1;       //bit 1
  unsigned int LS_ES_EXT : 1;         //bit 2
  unsigned int LS_NES_EXT : 1;        //bit 3
  unsigned int ANN_ARM_EXT : 1;       //bit 4
  unsigned int ANN_FIRE_EXT : 1;      //bit 5
  unsigned int VDC28_PRT_EXT : 1;     //bit 6
  unsigned int PWR_OFF_DSCT_EXT : 1;  //bit 7
};
Gimbal data;

#define MCU_LS_ARM_EXT 2  //pinout
#define MCU_POWER_OFF 3   //pinout
#define MCU_LS_ES_EXT 4   //pinout
#define MCU_LS_NES_EXT 5  //pinout
#define MCU_28V_PRT 6     //pinin
#define MCU_FIRE_ANN 7    //pinin
#define MCU_ARM_ANN 8     //pinin
#define MCU_INTERLOCK 9   //pinin

byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192, 168, 200, 8);
IPAddress destIp(192, 168, 200, 255);
unsigned int localPort = 1161;
unsigned int destPort = 1150;
EthernetUDP Udp;
char packetBuffer[UDP_TX_PACKET_MAX_SIZE];

unsigned long previousTimeUdp = 0;
const int intervalTimeUdp = 10000;
bool timerFlagTX = false;
bool timerFlagRX = false;
int timerCount = 0;

void setup() {
  Serial.begin(9600);
  pinMode(MCU_LS_ARM_EXT, OUTPUT);
  pinMode(MCU_POWER_OFF, OUTPUT);
  pinMode(MCU_LS_ES_EXT, OUTPUT);
  pinMode(MCU_LS_NES_EXT, OUTPUT);

  digitalWrite(MCU_LS_ARM_EXT, 0);
  digitalWrite(MCU_LS_ES_EXT, 0);
  digitalWrite(MCU_LS_NES_EXT, 0);
  digitalWrite(MCU_POWER_OFF, 0);

  pinMode(MCU_28V_PRT, INPUT);
  pinMode(MCU_FIRE_ANN, INPUT);
  pinMode(MCU_ARM_ANN, INPUT);
  pinMode(MCU_INTERLOCK, INPUT);

  Ethernet.begin(mac, ip);
  Udp.begin(localPort);

  Timer1.initialize(10000);
  Timer1.attachInterrupt(timerISR);
}
void loop() {
  if (timerFlagRX) {
    timerFlagRX = false;
    Serial.print("data : ");
    Serial.print(data.PWR_OFF_DSCT_EXT);
    Serial.print(data.VDC28_PRT_EXT);
    Serial.print(data.ANN_FIRE_EXT);
    Serial.print(data.ANN_ARM_EXT);
    Serial.print(data.LS_NES_EXT);
    Serial.print(data.LS_ES_EXT);
    Serial.print(data.LS_INTL_EXT);
    Serial.println(data.LS_ARM_EXT);
    unsigned long currentTimeUdp = millis();
    int packetSize = Udp.parsePacket();

    if (packetSize == 1) {
      Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE);
      data.LS_ARM_EXT = bitRead(packetBuffer[0], 0);
      digitalWrite(MCU_LS_ARM_EXT, data.LS_ARM_EXT);
      data.LS_ES_EXT = bitRead(packetBuffer[0], 2);
      digitalWrite(MCU_LS_ES_EXT, data.LS_ES_EXT);
      data.LS_NES_EXT = bitRead(packetBuffer[0], 3);
      digitalWrite(MCU_LS_NES_EXT, data.LS_NES_EXT);
      data.PWR_OFF_DSCT_EXT = bitRead(packetBuffer[0], 7);
      digitalWrite(MCU_POWER_OFF, data.PWR_OFF_DSCT_EXT);
      previousTimeUdp = currentTimeUdp;
    }

    if (currentTimeUdp - previousTimeUdp >= intervalTimeUdp) {
      data.LS_ARM_EXT = 0;
      digitalWrite(MCU_LS_ARM_EXT, 0);
      data.LS_ES_EXT = 0;
      digitalWrite(MCU_LS_ES_EXT, 0);
      data.LS_NES_EXT = 0;
      digitalWrite(MCU_LS_NES_EXT, 0);
      data.PWR_OFF_DSCT_EXT = 0;
      digitalWrite(MCU_POWER_OFF, 0);
    }

    if (data.LS_INTL_EXT != digitalRead(MCU_INTERLOCK)) {
      data.LS_INTL_EXT = digitalRead(MCU_INTERLOCK);
    }
    if (data.ANN_ARM_EXT != digitalRead(MCU_ARM_ANN)) {
      data.ANN_ARM_EXT = digitalRead(MCU_ARM_ANN);
    }
    if (data.ANN_FIRE_EXT != digitalRead(MCU_FIRE_ANN)) {
      data.ANN_FIRE_EXT = digitalRead(MCU_FIRE_ANN);
    }
    if (data.VDC28_PRT_EXT != digitalRead(MCU_28V_PRT)) {
      data.VDC28_PRT_EXT = digitalRead(MCU_28V_PRT);
    }
  }

  if (timerFlagTX) {
    timerFlagTX = false;
    Udp.beginPacket(destIp, destPort);
    Udp.write((byte*)&data, sizeof(Gimbal));
    Udp.endPacket();
  }
}

void timerISR() {
  timerFlagRX = true;
  timerCount++;  //1ทริค = 10 ms 10*20 = 200 ms
  if (timerCount >= 20) {
    timerFlagTX = true;
    timerCount = 0;
  }
}
