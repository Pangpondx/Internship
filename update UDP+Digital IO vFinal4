#include <SPI.h>
#include <Ethernet.h>
#include <TimerOne.h>
#include <stdint.h>
 
typedef struct {
  uint8_t LS_ARM_EXT : 1;         
  uint8_t LS_INTL_EXT : 1;        
  uint8_t LS_ES_EXT : 1;         
  uint8_t LS_NES_EXT : 1;         
  uint8_t ANN_ARM_EXT : 1;        
  uint8_t ANN_FIRE_EXT : 1;       
  uint8_t VDC28_PRT_EXT : 1;      
  uint8_t PWR_OFF_DSCT_EXT : 1;   
} ARGOS8_CONTROL_T;

ARGOS8_CONTROL_T argos8_status;
 
#define OUTPUT_MCU_LS_ARM_EXT 2   
#define OUTPUT_MCU_POWER_OFF 3    
#define OUTPUT_MCU_LS_ES_EXT 4    
#define OUTPUT_MCU_LS_NES_EXT 5   
#define INPUT_MCU_28V_PRT 6      
#define INPUT_MCU_FIRE_ANN 7     
#define INPUT_MCU_ARM_ANN 8      
#define INPUT_MCU_INTERLOCK 9    
 
const byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress localIp(192, 168, 200, 8);
IPAddress desIp(192, 168, 255, 255);
IPAddress dns(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnetMask(255, 255, 0, 0);
const uint16_t localPort = 1161;
const uint16_t desPort = 1150;
EthernetUDP Udp;
 
uint32_t lastTimeLostUdp = 0;
const uint16_t UdpLostTimeout = 10000;

bool timerFlag100Hz = false;
uint8_t timerCount = 0;
uint8_t trick5Hz = 20; //10 * 20 = 200 ms

uint32_t lastDebounceTimeInterlock = 0;
const uint8_t debounceInterlockDelay = 50;

void timerISR() {
  timerFlag100Hz = true;
  timerCount++; 
}
 
void setup() {
  Serial.begin(9600);
  pinMode(OUTPUT_MCU_LS_ARM_EXT, OUTPUT);
  pinMode(OUTPUT_MCU_POWER_OFF, OUTPUT);
  pinMode(OUTPUT_MCU_LS_ES_EXT, OUTPUT);
  pinMode(OUTPUT_MCU_LS_NES_EXT, OUTPUT);
 
  digitalWrite(OUTPUT_MCU_LS_ARM_EXT, 0);
  digitalWrite(OUTPUT_MCU_LS_ES_EXT, 0);
  digitalWrite(OUTPUT_MCU_LS_NES_EXT, 0);
  digitalWrite(OUTPUT_MCU_POWER_OFF, 0);
 
  pinMode(INPUT_MCU_28V_PRT, INPUT);
  pinMode(INPUT_MCU_FIRE_ANN, INPUT);
  pinMode(INPUT_MCU_ARM_ANN, INPUT);
  pinMode(INPUT_MCU_INTERLOCK, INPUT);
 
  Ethernet.begin(mac, localIp, dns, gateway, subnetMask);
  Udp.begin(localPort);
 
  Timer1.initialize(10000);
  Timer1.attachInterrupt(timerISR);
}
 
void loop() {
  if (timerFlag100Hz) {
    timerFlag100Hz = false;
    // For debug
    Serial.print("data : ");
    Serial.print(argos8_status.PWR_OFF_DSCT_EXT);
    Serial.print(argos8_status.VDC28_PRT_EXT);
    Serial.print(argos8_status.ANN_FIRE_EXT);
    Serial.print(argos8_status.ANN_ARM_EXT);
    Serial.print(" ");
    Serial.print(argos8_status.LS_NES_EXT);
    Serial.print(argos8_status.LS_ES_EXT);
    Serial.print(argos8_status.LS_INTL_EXT);
    Serial.println(argos8_status.LS_ARM_EXT);
 
    uint8_t udpSize = Udp.parsePacket();
 
    if (udpSize > 0) {
      uint8_t packetBuffer[5];
      Udp.read(packetBuffer, udpSize);
      
      if (udpSize == 1){
      memcpy(&argos8_status, &packetBuffer, 1);
      digitalWrite(OUTPUT_MCU_LS_ARM_EXT, argos8_status.LS_ARM_EXT);
      digitalWrite(OUTPUT_MCU_LS_ES_EXT, argos8_status.LS_ES_EXT);
      digitalWrite(OUTPUT_MCU_LS_NES_EXT, argos8_status.LS_NES_EXT);
      digitalWrite(OUTPUT_MCU_POWER_OFF, argos8_status.PWR_OFF_DSCT_EXT);
      lastTimeLostUdp = millis();
      }
    }
 
    if (millis() - lastTimeLostUdp >= UdpLostTimeout) {
      argos8_status.LS_ARM_EXT = 0;
      digitalWrite(OUTPUT_MCU_LS_ARM_EXT, 0);
      argos8_status.LS_ES_EXT = 0;
      digitalWrite(OUTPUT_MCU_LS_ES_EXT, 0);
      argos8_status.LS_NES_EXT = 0;
      digitalWrite(OUTPUT_MCU_LS_NES_EXT, 0);
      argos8_status.PWR_OFF_DSCT_EXT = 0;
      digitalWrite(OUTPUT_MCU_POWER_OFF, 0);
    }
    uint8_t reading_Interlock = digitalRead(INPUT_MCU_INTERLOCK); 
    //debounce
    if ((millis() - lastDebounceTimeInterlock) > debounceInterlockDelay && reading_Interlock != argos8_status.LS_INTL_EXT){
      lastDebounceTimeInterlock = millis();
        argos8_status.LS_INTL_EXT = reading_Interlock;
    }
    
    argos8_status.ANN_ARM_EXT = digitalRead(INPUT_MCU_ARM_ANN);
    argos8_status.ANN_FIRE_EXT = digitalRead(INPUT_MCU_FIRE_ANN);
    argos8_status.VDC28_PRT_EXT = digitalRead(INPUT_MCU_28V_PRT);
  }
 
  if (timerCount >= trick5Hz) {
    timerCount = 0;
    Udp.beginPacket(desIp, desPort);
    Udp.write((byte*)&argos8_status, sizeof(ARGOS8_CONTROL_T));
    Udp.endPacket();
  }
}
